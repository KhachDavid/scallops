<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>3D Scallop Vision Simulation</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
      }
      canvas {
        display: block;
        flex-grow: 1;
      }
      #info {
        position: absolute;
        top: 10px;
        text-align: center;
        width: 100%;
        color: #333;
      }
      #info h1 {
        margin: 0;
        font-size: 1.5em;
      }
      #info p {
        margin: 5px 0 0;
        font-size: 1em;
      }
      /* Sidebar styling */
      #sidebar {
        position: fixed;
        top: 20px;
        left: 20px;
        background-color: rgba(0, 0, 0, 0.7);
        color: white;
        padding: 15px;
        font-family: Arial, sans-serif;
        font-size: 16px;
        border-radius: 10px;
        z-index: 10;
      }

      .sidebar-item {
        margin: 10px 0;
      }

      .threat {
        color: red;
      }

      .prey {
        color: green;
      }

      button {
        left: 200px;
        padding: 10px;
        background-color: #4caf50;
        color: white;
        border: none;
        cursor: pointer;
        z-index: 10;
      }

      .checkbox-container {
        margin-top: 10px;
        margin-bottom: 10px;
      }

      .checkbox-label {
        display: inline-block;
        margin-left: 5px;
      }
    </style>
  </head>
  <body>
    <div id="sidebar">
      <div class="sidebar-item threat">Red ones are threats</div>
      <div class="sidebar-item prey">Green ones are prey</div>
      <div class="checkbox-container">
        <input type="checkbox" id="scanToggle" checked />
        <label for="scanToggle" class="checkbox-label">Enable Scan Beams</label>
      </div>
      <button id="toggleShell">Toggle Shell</button>
    </div>
    <div id="info">
      <h1 style="color: white">3D Scallop Vision Simulation</h1>
      <p style="color: white">
        Drag to rotate, scroll to zoom, observe the scallop's reaction to light!
      </p>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/23.1.3/tween.umd.js"></script>

    <script>
      // Setup the scene, camera, and renderer
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      const renderer = new THREE.WebGLRenderer();
      const raycaster = new THREE.Raycaster();
      const mouse = new THREE.Vector2();
      let selectedEye = null;
      let eyeDetailText = null;

      // Function to animate the camera to focus on a specific eye
      function zoomToEye(eye) {
        const targetPosition = eye.position.clone();
        const cameraTarget = new THREE.Vector3(
          targetPosition.x,
          targetPosition.y,
          targetPosition.z
        ).add(targetPosition.clone().normalize().multiplyScalar(5)); // Offset slightly for better visibility

        // Animate camera movement
        new TWEEN.Tween(camera.position)
          .to(
            {
              x: cameraTarget.x,
              y: cameraTarget.y,
              z: cameraTarget.z,
            },
            1000 // Animation duration
          )
          .easing(TWEEN.Easing.Cubic.Out)
          .start();

        // Add inside-eye detail visualization
        // Add inside-eye detail visualization

        // Add sidebar for explaining layers of the eye
        let eyeSidebar = document.createElement("div");
        eyeSidebar.style.color = "white";
        eyeSidebar.style.backgroundColor = "rgba(0, 0, 0, 0.8)";
        eyeSidebar.style.width = "300px";
        eyeSidebar.style.padding = "15px";
        eyeSidebar.style.borderRadius = "10px";
        eyeSidebar.style.position = "absolute";
        eyeSidebar.style.top = "50px";
        eyeSidebar.style.right = "20px";
        eyeSidebar.style.fontFamily = "Arial, sans-serif";
        eyeSidebar.style.boxShadow = "0 4px 8px rgba(0, 0, 0, 0.3)";

        // Populate sidebar with explanations
        eyeSidebar.innerHTML = `
  <h2>Layers of the Scallop's Eye</h2>
  <ul>
    <li><strong style="color: #007bff">Lens:</strong> Although they do not have a typical crystalline lens capable of strong refraction, they do have a gelatinous region at the front of their eye (roughly analogous to the vitreous humour in a human eye) that acts as a very weakly refracting lens. Light entering the scallop eye is refracted, but not to the extent that it forms a clear image on the back of the eye.</li>
    <li><strong style="color: #4E2A84">Distal Retina:</strong> The outer layer of the retina that detects bright light and provides a detailed image.</li>
    <li><strong style="color: #ff4500">Proximal Retina:</strong> The inner layer of the retina that detects dim light and helps in depth perception.</li>
    <li><strong style="color: #62361b">Mirror:</strong> A concave structure that reflects light back through the retinas, enhancing sensitivity and enabling a wide field of vision.</li>
  </ul>
  <p>The scallop's eye uses both retinas and the mirror to create a unique optical system, allowing it to detect predators and food efficiently.</p>
`;

        // Append sidebar to the document
        document.body.appendChild(eyeSidebar);
      }

      // Restore camera view
      function resetCameraView() {
        new TWEEN.Tween(camera.position)
          .to({ x: 0, y: 0, z: 30 }, 1000)
          .easing(TWEEN.Easing.Cubic.Out)
          .start();
        if (eyeDetailText) {
          document.body.removeChild(eyeDetailText);
          eyeDetailText = null;
        }
      }

      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      scene.background = new THREE.Color(0x1f3b5f); // Darker blue for underwater effect
      scene.fog = new THREE.Fog(0x1f3b5f, 10, 100); // Underwater fog

      // Add lighting to the scene
      const light = new THREE.PointLight(0xff0000, 1, 100); // Red point light
      scene.add(light);

      const ambientLight = new THREE.AmbientLight(0xeae0c8, 1); // Higher intensity for ambient light
      scene.add(ambientLight);

      // Create a sphere for the light source
      const lightGeometry = new THREE.SphereGeometry(0.5, 16, 16);
      const lightMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
      const lightMesh = new THREE.Mesh(lightGeometry, lightMaterial);
      light.add(lightMesh);

      // Create the scallop body
      const scallopGeometry = new THREE.SphereGeometry(10, 32, 16);
      const scallopMaterial = new THREE.MeshLambertMaterial({
        color: 0xf5deb3,
        wireframe: false,
      });
      const scallop = new THREE.Mesh(scallopGeometry, scallopMaterial);
      scallop.scale.set(1, 0.6, 1);
      scene.add(scallop);
      const debugRay = new THREE.ArrowHelper(
        raycaster.ray.direction,
        raycaster.ray.origin,
        10,
        0xff0000
      );
      scene.add(debugRay);
      // Add the scallop's eyes along the midsection (equator of the ovoid)
      const numEyes = 20; // Reduced for clarity
      const eyeGroup = new THREE.Group();
      const eyeBeams = [];

      for (let i = 0; i < numEyes; i++) {
        // Position eyes along the equator of the ovoid
        const angle = (i / numEyes) * Math.PI * 2; // Spread evenly around the equator
        const x = 10 * Math.cos(angle); // Radius along x-axis
        const y = 0; // Centered on midsection
        const z = 10 * Math.sin(angle); // Radius along z-axis

        // Create an eye. The eye is in the middle
        const eyeGeometry = new THREE.SphereGeometry(0.3, 16, 16);
        const eyeMaterial = new THREE.MeshPhongMaterial({
          color: 0x000000,
          emissive: 0x000000,
        });
        const eye = new THREE.Mesh(eyeGeometry, eyeMaterial);

        // Position the eye and add it to the group
        eye.position.set(x, y, z);

        // Base eye geometry
        eye.castShadow = true;

        // Add the mirror (m) at the back of the eye
        const mirrorGeometry = new THREE.SphereGeometry(0.8, 32, 32);
        const mirrorMaterial = new THREE.MeshStandardMaterial({
          color: 0xffffff,
          metalness: 1,
          roughness: 0,
          side: THREE.BackSide, // Internal reflection
        });
        const mirror = new THREE.Mesh(mirrorGeometry, mirrorMaterial);
        mirror.position.set(0, 0, 0); // Slightly recessed mirror
        eye.add(mirror);

        // Add the distal retina (r)
        const distalRetinaGeometry = new THREE.SphereGeometry(0.7, 32, 32);
        const distalRetinaMaterial = new THREE.MeshBasicMaterial({
          color: 0x4E2A84, // Purple
          opacity: 0.7,
          transparent: true,
          side: THREE.BackSide,
        });
        const distalRetina = new THREE.Mesh(
          distalRetinaGeometry,
          distalRetinaMaterial
        );
        distalRetina.position.set(0, 0, 0); // Retina floats inside
        eye.add(distalRetina);

        // Add the proximal retina (inner retina)
        const proximalRetinaGeometry = new THREE.SphereGeometry(0.6, 32, 32);
        const proximalRetinaMaterial = new THREE.MeshBasicMaterial({
          color: 0xff4500, // Deeper red
          opacity: 0.5,
          transparent: true,
          side: THREE.BackSide,
        });
        const proximalRetina = new THREE.Mesh(
          proximalRetinaGeometry,
          proximalRetinaMaterial
        );
        proximalRetina.position.set(0, 0, 0);
        eye.add(proximalRetina);

        // Add the very weakly refracting gelatinous lens (l)
        const lensGeometry = new THREE.SphereGeometry(0.9, 32, 32); // Slightly larger than retina
        const lensMaterial = new THREE.MeshStandardMaterial({
          color: 0xeeeeee, // Light grey for weak refraction
          opacity: 0.3,
          transparent: true,
        });
        const lens = new THREE.Mesh(lensGeometry, lensMaterial);
        lens.position.set(0, 0, 0);
        eye.add(lens);

        // Add the thin blue coating (o) around the edges with an open front
        const blueCoatingGeometry = new THREE.SphereGeometry(
          1.1,
          64,
          64,
          0,
          Math.PI * 2,
          Math.PI * 0.6,
          0,
          Math.PI
        );
        const blueCoatingMaterial = new THREE.MeshStandardMaterial({
          color: 0x007bff, // Bright blue
          emissive: 0x0033aa, // Subtle glow from the edges
          emissiveIntensity: 0.5, // Glow intensity
          metalness: 0.7,
          roughness: 0.3,
          opacity: 0.95,
          transparent: true,
        });
        const blueCoating = new THREE.Mesh(
          blueCoatingGeometry,
          blueCoatingMaterial
        );
        blueCoating.position.set(0, 0, 0); // Centered around the eye
        eye.add(blueCoating);

        // Outer glow layer for additional visibility
        const outerGlowGeometry = new THREE.SphereGeometry(1.15, 64, 64);
        const outerGlowMaterial = new THREE.MeshBasicMaterial({
          color: 0x007bff, // Bright blue
          opacity: 0.4, // Semi-transparent
          transparent: true,
        });
        const outerGlow = new THREE.Mesh(outerGlowGeometry, outerGlowMaterial);
        eye.add(outerGlow);

        // Spotlight to emphasize the blue coating
        // Spotlight to emphasize the blue coating
        const spotlight = new THREE.SpotLight(0xffffff, 1.5); // Bright white light
        spotlight.position.set(0, 0, 3); // Position slightly in front of the eye
        spotlight.target = eye; // Target the eye
        spotlight.angle = Math.PI / 8; // Narrow spotlight beam
        spotlight.penumbra = 0.2; // Softer edges
        spotlight.distance = 15; // Limit the range of the light
        eye.add(spotlight);
        scene.add(spotlight.target); // Ensure target is part of the scene

        // Add the entire eye to the scene
        scene.add(eye);

        eyeGroup.add(eye);

        // Create a beam (ray) for each eye
        const beamGeometry = new THREE.CylinderGeometry(0.05, 0.05, 30, 8);
        const beamMaterial = new THREE.MeshBasicMaterial({
          color: 0x00ff00,
          opacity: 0.5,
          transparent: true,
        });
        const beam = new THREE.Mesh(beamGeometry, beamMaterial);
        const eyeDirection = new THREE.Vector3(x, y, z).normalize(); // Normalize to get unit vector
        const perpendicularDirection = new THREE.Vector3(
          -eyeDirection.z,
          0,
          eyeDirection.x
        ); // Perpendicular in X-Z plane

        // use x y z to rotate the beat around the x axis but the angle should be calculated based on their posiion
        beam.scale.set(0.1, 0.1, 0.1); // Adjust length as needed
        beam.rotation.x = Math.PI / 2;
        beam.rotation.z = Math.atan2(eyeDirection.x, -eyeDirection.z);

        // beam should only point away from the eye
        beam.position.set(x, y, z); // Position the beam at the eye

        scene.add(beam);
        eyeBeams.push(beam);
      }

      scene.add(eyeGroup);

      // Create the top and bottom shells
      const shellTopGeometry = new THREE.SphereGeometry(
        10,
        32,
        16,
        0,
        Math.PI * 2,
        0,
        Math.PI / 2
      );
      const shellBottomGeometry = new THREE.SphereGeometry(
        10,
        32,
        16,
        0,
        Math.PI * 2,
        Math.PI / 2,
        Math.PI / 2
      );
      const shellMaterial = new THREE.MeshLambertMaterial({
        color: 0x996633,
        wireframe: false,
      });

      const shellTop = new THREE.Mesh(shellTopGeometry, shellMaterial);
      const shellBottom = new THREE.Mesh(shellBottomGeometry, shellMaterial);
      shellTop.position.y = 2; // Position the top shell
      shellBottom.position.y = -2; // Position the bottom shell
      shellTop.scale.set(1, 0.6, 1); // Flatten the top shell
      shellBottom.scale.set(1, 0.6, 1); // Flatten the bottom shell
      scene.add(shellTop);
      scene.add(shellBottom);

      // Set up camera position
      camera.position.z = 30;

      // Add orbit controls for dragging and zooming
      const controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true; // Smooth dragging
      controls.dampingFactor = 0.05;

      let isShellOpen = false; // Flag to track if the shell is open
      let isAnimating = false; // Flag to check if the shell is in the process of opening/closing

      // Button to toggle shell opening and closing
      document.getElementById("toggleShell").addEventListener("click", () => {
        if (!isAnimating) {
          isShellOpen = !isShellOpen; // Toggle shell state
          isAnimating = true; // Start animation
        }
      });

      // Raycasting setup
      document.body.addEventListener(
        "click",
        (event) => {
          // Calculate mouse position in normalized device coordinates
          mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
          mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
          raycaster.setFromCamera(mouse, camera);
          const intersects = raycaster.intersectObjects(eyeGroup.children);
          console.log("Intersections:", intersects); // Check if anything is detected
          if (intersects.length > 0) {
            const clickedEye = intersects[0].object;
            if (clickedEye !== selectedEye) {
              selectedEye = clickedEye;
              zoomToEye(clickedEye);
            } else {
              resetCameraView();
              selectedEye = null;
            }
          }
        },
        false
      );

      const scanToggle = document.getElementById("scanToggle");
      scanToggle.addEventListener("change", (e) => {
        eyeBeams.forEach((beam) => {
          beam.visible = e.target.checked;
        });
      });

      // Animate the light source with sinusoidal movement
      let time = 0; // Keeps track of time for sinusoidal motion
      function animate() {
        requestAnimationFrame(animate);

        TWEEN.update();
        // Update light position using sinusoidal motion
        time += 0.02;
        light.position.x = 15 * Math.sin(time); // Moves horizontally in a wave
        light.position.y = 5 * Math.sin(time * 0.5); // Moves vertically slower
        light.position.z = 15 * Math.cos(time); // Moves around the scallop

        // Animate the shell opening/closing with discrete steps
        if (isShellOpen) {
          if (shellTop.position.y < 6) {
            // Move top shell up
            shellTop.position.y += 0.1;
          } else {
            isAnimating = false; // Stop animation when fully open
          }
        } else {
          if (shellTop.position.y > 2) {
            // Move top shell down
            shellTop.position.y -= 0.1;
          } else {
            isAnimating = false; // Stop animation when fully closed
          }
        }

        // Update eye brightness based on distance to light
        eyeGroup.children.forEach((eye, index) => {
          const distance = light.position.distanceTo(eye.position);
          const intensity = Math.max(0, 1 - distance / 20); // Inverse distance effect
          eye.material.emissive.setRGB(intensity, 0, 0); // Blue glow

          // Animate the beams to extend outward
          if (scanToggle.checked) {
            const beam = eyeBeams[index];
            const length = Math.sin(time + index) * 15 + 10; // Vary length for scanning effect
            beam.scale.set(1, length, 1); // Stretch the beam
          }
        });

        controls.update(); // Update orbit controls
        renderer.render(scene, camera);
      }

      animate();

      // Handle resizing
      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>
